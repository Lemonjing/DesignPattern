# designpattern
## 设计模式

1. 策略模式 Strategy

2. 观察者模式 Observer

3. 装饰者模式 Decorator

4. 工厂方法模式 FactoryMethod

5. 抽象工厂模式 AbstractFactory

6. 单件模式 Singleton

7. 命令模式 Command

8. 适配器模式 Adapater

9. 外观模式 Facade

10. 模板方法模式 TemplateMethod

11. 迭代器模式 Iterator

12. 组合模式 Composite

13. 状态模式 State

14. 代理模式 Proxy

15. 复合模式 Combined

16. 桥接模式 Bridge
 - 定义：不仅改变你的实现也改变你的抽象。桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变。

17. 生成器模式 Builder
 - 生成器模式封装一个产品的构造过程并允许按步骤构造。

18. 责任链模式 Chain of responsibility
 - 通过责任链模式为某个请求创建一个对象链。每个对象一次检查此请求，并对其处理，或将它传给链中的下一个对象。

19. 蝇量模式(享元模式) Flyweight
 - 当一个类有许多实例，而这些实例能被同一方法控制，我们使用蝇量模式。蝇量模式为某个的实例提供多个“虚拟实例”。

20. 解释器模式 Interpreter
 - 为简单语言创建解释器。

21. 中介者 Mediator　
 - 中介者模式集中相关对象之间复杂的沟通和控制方式。中介者包含了整个系统的控制逻辑。

22. 备忘录 Memento　
 - 需要将对象的状态保存。

23. 原型 Prototype
 - 当创建给定类的实例的过程非常昂贵或复杂时使用原型模式。原型模式允许你通过复制现有的实例来创建新的实例。

24. 访问者
 - 当想要为一个对象的组合增加新的能力，且封装不重要时可以使用访问者模式。使用访问者会打破组合类的封装。


## 面向对象设计原则

1. 封装变化
2. 少用继承 多用组合
3. 针对接口编程 不针对实现编程
4. 为交互对象之间的松耦合设计而努力
5. 类应该对扩展开发 对修改封闭（开闭OCP原则）
6. 依赖抽象，不要依赖于具体类（依赖倒置DIP原则）
7. 密友原则：只和朋友交谈（最少知识原则）
	
	说明：将方法调用保持在界限内，只调用属于以下范围的方法：
	该对象本身（本地方法）对象的组件 被当作方法参数传进来的对象 此方法创建或实例化的任何对象

8. 别找我（调用我） 我会找你（调用你）（好莱坞原则）
9. 一个类只有一个引起它变化的原因（单一职责SRP原则）